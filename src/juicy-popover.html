<!--
`juicy-popover` - Custom Element that expands an area when clicked on a handle
@element juicy-popover
version: 1.2.0
-->
<template id="juicy-popover-template">
    <style>
        :host {
            display: block;
        }

        #container {
            position: relative;
        }

        #handle {
            display: inline-block;
        }

        #expandable {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 999;
        }

        #expandable.expanded {
            display: inline-block;
        }
    </style>
    <div id="container">
        <div id="handle">
            <slot name="handle"></slot>
            <content select="[slot='handle']"></content>
        </div>
        <div id="expandable">
            <slot id="deprecated-v1" name="expendable"></slot>
            <content id="deprecated-v0" select="[slot='expendable']"></content>
            <slot name="expandable"></slot>
            <content select="[slot='expandable']"></content>
        </div>
    </div>
</template>

<script>
    (function (global, document) {
        
        const importDoc = (document._currentScript || document.currentScript).ownerDocument;
        const template = importDoc.querySelector('#juicy-popover-template');

        let usedShadyCss = false;
        if (window.ShadowDOMPolyfill) {
            WebComponents.ShadowCSS.shimStyling(template.content, 'juicy-popover');
        } else if (window.ShadyCSS) {
            usedShadyCss = true;
            ShadyCSS.prepareTemplate(template, 'juicy-popover');
        }
        function doesItFit(bounding) {
            //if this fails then switch to the library https://github.com/patik/within-viewport
            return (
                bounding.top >= 0 &&
                bounding.left >= 0 &&
                bounding.bottom <= document.body.clientHeight &&
                bounding.right <= document.body.clientWidth
            );
        }
        function proposeRect(position, handleRect, expandableRect) {
            const newExpandableRect = {
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            };
            if (position.includes('beforetop')) {
                newExpandableRect.top = handleRect.top - expandableRect.height;

            } else if (position.includes('beforebottom')) {
                newExpandableRect.top = handleRect.top + handleRect.height - expandableRect.height;

            } else if (position.includes('top')) {
                newExpandableRect.top = handleRect.top;

            } else {
                newExpandableRect.top = handleRect.top + handleRect.height;
            }
            newExpandableRect.bottom = newExpandableRect.top + expandableRect.height;

            if (position.includes('beforeleft')) {
                newExpandableRect.left = handleRect.left - expandableRect.width;
            } else if (position.includes('beforeright')) {
                newExpandableRect.left = handleRect.left + handleRect.width - expandableRect.width;
            } else if (position.includes('right')) {
                newExpandableRect.left = handleRect.left + handleRect.width;
            } else {
                newExpandableRect.left = handleRect.left;
            }
            newExpandableRect.right = newExpandableRect.left + expandableRect.width;

            return newExpandableRect;
        }

        class JuicyPopoverElement extends HTMLElement {

            get disabled() {
                return this.getAttribute('disabled');
            }

            set disabled(val) {
                if (val) {
                    this.removeAttribute('expanded');
                    this.setAttribute('disabled', '');
                }
                else {
                    this.removeAttribute('disabled');
                }
            }

            get expanded() {
                return this.getAttribute('expanded');
            }

            set expanded(val) {
                if (val) {
                    this.setAttribute('expanded', '');
                } else {
                    this.removeAttribute('expanded');
                }
            }

            static get observedAttributes() {
                return ['disabled', 'expanded'];
            }

            constructor(self) {
                // Polyfill ceveat we need to fetch the right context;
                // https://github.com/WebReflection/document-register-element/tree/master#v1-caveat
                self = super(self);

                if (usedShadyCss) {
                    ShadyCSS.styleElement(self);
                }

                // Creates the shadow root
                let shadowRoot;
                if (self.attachShadow && self.getRootNode) {
                    shadowRoot = self.attachShadow({ mode: 'open' });
                } else {
                    shadowRoot = self.createShadowRoot();
                }

                const clone = document.importNode(template.content, true);
                shadowRoot.appendChild(clone);
                
                self.ignore = false;
                const handle = this.shadowRoot.querySelector("#handle");
                const expandable = this.shadowRoot.querySelector("#expandable");

                handle.addEventListener("mousedown", ev => {
                    if (!expandable.classList.contains("expanded")) {
                        self.expand();
                        self.ignore = true;
                    }
                });

                handle.addEventListener("mouseup", ev => {
                    if (ev.target.nodeName == "INPUT") {
                        self.ignore = true; //just a friendly feature - don't collapse the expandable if clicked on a handler which is an input
                    }
                });

                expandable.addEventListener("mousedown", ev => {
                    self.ignore = true;
                });

                window.addEventListener("mouseup", ev => {
                    if (!self.ignore && expandable.classList.contains("expanded")) {
                        self.collapse();
                    }
                    self.ignore = false;
                });

                window.addEventListener("resize", e => {
                    if (expandable.classList.contains("expanded")) {
                        self.reposition();
                    }
                });
                // This will work only in V1
                shadowRoot.getElementById('deprecated-v1').addEventListener('slotchange', ev => {
                    const slottedElements = ev.target.assignedNodes();
                    console.warn('Slot name `expendable` is deprecated, please use `expandable`!', slottedElements);
                });

                return self;
            }

            attributeChangedCallback(attr, oldVal, newVal) {
                switch (attr) {
                    case "disabled":
                        if (newVal !== null) {
                            this.removeAttribute('expanded');
                        }
                        break;
                    case "expanded":
                        if (newVal !== null) {
                            this._expand();
                        } else {
                            this._collapse();
                        }
                }
            }
            connectedCallback() {
                const slottedElements = this.attachShadow ?
                    this.shadowRoot.getElementById('deprecated-v1').assignedNodes() :
                    this.shadowRoot.getElementById('deprecated-v0').getDistributedNodes();

                if (slottedElements.length) {
                    console.warn('Slot name `expendable` is deprecated, please use `expandable`!', slottedElements);
                }
            }

            reposition() {
                const container = this.shadowRoot.querySelector("#container");
                const expandable = this.shadowRoot.querySelector("#expandable");
                const handle = this.shadowRoot.querySelector("#handle");

                const config = this.getAttribute("position") || "bottom left, bottom beforeright, beforetop left, beforetop beforeright";
                const positions = config.split(",");

                if (expandable.classList.contains("expanded")) {
                    this._hideExpandable();
                }

                const containerRect = container.getBoundingClientRect();
                const handleRect = handle.getBoundingClientRect();

                this._showExpandable();

                const expandableRect = expandable.getBoundingClientRect();

                positions.some((position, index) => {
                    const newExpandableRect = proposeRect(position, handleRect, expandableRect);
                    const isLastIndex = (index + 1 == positions.length);
                    if (isLastIndex || doesItFit(newExpandableRect)) {
                        const top = newExpandableRect.top - containerRect.top;
                        const left = newExpandableRect.left - containerRect.left;
                        expandable.style.top = `${top}px`;
                        expandable.style.left = `${left}px`;
                        return true;
                    }
                });
            }

            expand() {
                this.expanded = true;
            };

            _expand() {
                if (this.hasAttribute('disabled')) {
                    return;
                }

                this.reposition();

                var e = new Event("juicy-popover-expand");
                this.dispatchEvent(e);
                var e = new Event("expanded-changed");
                this.dispatchEvent(e);
            };

            collapse() {
                this.expanded = false;
            };

            _collapse() {
                this._hideExpandable();

                var e = new Event("juicy-popover-collapse");
                this.dispatchEvent(e);
                var e = new Event("expanded-changed");
                this.dispatchEvent(e);
            };

            _showExpandable() {
                this.shadowRoot.querySelector("#expandable").classList.add("expanded");
                this.classList.add("expanded");
            };

            _hideExpandable() {
                this.shadowRoot.querySelector("#expandable").classList.remove("expanded");
                this.classList.remove("expanded");
            };
        }

        global.customElements.define('juicy-popover', JuicyPopoverElement);
    })(window, document);
</script>